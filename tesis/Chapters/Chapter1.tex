% Chapter 1

\chapter{Theoretical Introduction} % Main chapter title

\label{Chapter1} % For referencing the chapter elsewhere, use \ref{Chapter1} 

% ----------------------------------------------------------------------------------------

% Define some commands to keep the formatting separated from the content 
\newcommand{\keyword}[1]{\textbf{#1}}
\newcommand{\tabhead}[1]{\textbf{#1}}
\newcommand{\code}[1]{\texttt{#1}}
\newcommand{\file}[1]{\texttt{\bfseries#1}}
\newcommand{\option}[1]{\texttt{\itshape#1}}

% ----------------------------------------------------------------------------------------
\section{Introducction}

TODO: incluir introducci贸n del problema.

Info:
- Handbook incluye una introducci贸n hist贸rica.
- Libro verde incluye una introducci贸n excelente.



\section{Boolean Algebra}

We could have started the topic right from the axioms. Nonetheless, given the goal we want to achieve, it seems excesive. We will reffer to the commonly used \emph{Zermelo-Fraenkel axioms}, in order to have a point of reference, and therefore we will work without more considerations with sets and sets operations. We will put \emph{Zorn's lemma} to work, so the axiom of choice will also be needed, although in practice we will only work with finite sets of formulas.\\

Further on this section we will present Boolean Algebra in a classic lattice-based way that could be found widely extended in related literature. In particular we follow the approach shown on  \cite{marek2009introduction}.

\begin{definition}
  A partial ordered set, also poset, is a pair $\{X, \le\}$ where $X$ is a set and $\\le$ is a partial order of $X$. A chain $Y$ of a $\{X, \le\}$ is a subset of $X$ where $\le$ is a total order. 
\end{denition}

\begin{proposition}[Zorn lemma]
  If every chain in a poset $\{X,\le\}$ is bounded, then $X$ possesses a maximal elements and for every $x\inX$ there is a maximal element $y$ such that $x\le y$.
\end{proposition}



\begin{definition} A lattice is a partial ordered set $\{X,\le\}$ where every pair of elements possesses a least upper bound and a greatest lower bound. A lattice will have two new operations defined, given two elements $x,y\in X$
  \begin{itemize}
  \item $x\vee y$ that dentoe the least upper bound.
  \item $x\wedge y$ that denote the greatest lower bound.
  \end{itemize}
  A lattice is complete if every subset has a unique largest element and a unique lowest element. A lattice could be presented generaly as a duple $\{L,\le\}$, a triple $\{X,\vee,\wedge\}$ and, if posible, would be presented as a quituple $\{X, \vee, \wedge, \top,\bot\}$ where $\top$ is the greatest elemente and $\bot$ the lowest element. a lattice is called distributive i $x\vee(y \wedge z) = (x\vee y) \wedge (x \vee z)$ and $x\wedge(y \vee z) = (x\wedge y) \vee (x \wedge z)$
\end{definition} 


With the contex of lattice just included, we will present the \emph{Knaster and Tarski fixpoint theorem} fixpoint theorem. In order to do that we will introduce some notation. Given $f:\{L,\le\}\to \{L,\le\}$ a function a prefixpoint (resp. postfixpoint) is a point $x \in L$ such that $f(x) \le x$ (resp. $f(x) \ge x$). A fixpoint is a point that is both prefixpoint and postfixpoint. Note that, given that they exists, $\top$ and $bot$ are a prefixpoint and a postfixpoint of $f$ respectively.

\begin{theorem}[proposition 1.2 \cite{marek2009introduction}]
  Let $f:\{L,\le\}\to \{L,\le\}$ be a monotone funtion in a complete lattice. Then:
  \begin{enumerate}
  \item $f$ has a least prefixpoint $l$ that is a fixpoint.
  \item $f$ has a largest postfixpoint $l$ that is a fixpoint.
  \end{enumerate}
\end{theorem}
\begin{proof}\\
  
  \begin{enumerate}
  \item We know that there is at least a prefixpoint. Let
    $$l = \bigwedge_{\{x\in X: x\text{ is a prefixpoint}\}} x $$. 
    Lets prove that $l$ is a fixpoint. Le $x$ be an arbitrary fixpoint, therefore, $l \le x \le f(x)$. Since $x$ was arbitrary, $f(l) \le l$. To show that it a fixpoint it suffices to see that $f(l)$ is a prefixpoint to, as $f$ is motone.
  \item Apply the previous result on $f:\{L,\le\}\to \{L,\le\}$.
  \end{enumerate}
\end{proof}
  
\begin{definition}
  A \emph{Boolean algebra} is a distributive lattice  $\{X, \vee, \wedge, \top,\bot\}$ with an additional operation $\neg$, called complement or negation, such that for all $x\inX$:
  \begin{enumerate}
  \item $ x\wedge \neg x = \bot,\ x\vee \neg x = \top $
  \item $ \neg(x \vee y) = \neg x \wedge \neg y,  \neg(x \wedge y) = \neg x \vee \neg y$
  \item $\neg \neg x = x$
  \end{enumerate}
\end{definition}
    


\section{Propositional Logic}



\section{Definitions and first concepts.}
    In this section Boolean formulas will be introduced. We first start with the basic building blocks, which collectively form what is called  the alphabet. Namely,
    \begin{itemize}
    \item Symbols $x,y,z$ for Boolean variables.
    \item Symbols $p,q,r$ for Boolean metavariables, that is, a variable that refer to a boolean variable or a negated (see below) boolean variable.
    \item Values 0 and 1, referring to false  and true respectively. The set $\{0,1\}$ will be named as $\mathbb{B}$.

    \item Boolean Operators: 
      \begin{itemize}
      \item unary: $\neg $
      \item binary: $\wedge, \vee, \rightarrow, \oplus, \leftrightarrow $
      \end{itemize}


      We will consider $\wedge$ of greater priority than $\vee$. These operator are defined by theirs truth table:

    \end{itemize}

    \vspace{0.5cm}
    \begin{tabular}{cccccccc}
      & &
          \begin{tabular}{c|cc}
            $\neg $ & 0 & 1 \\\hline
                    & 1 & 0
          \end{tabular} 


                    &
                      \begin{tabular}{c|cc}
                        $\vee$ & 0 & 1 \\\hline
                        0   & 0 & 1 \\
                        1   & 1 & 1
                      \end{tabular} 
                    & 
                      
                      \begin{tabular}{c|cc}
                        $\wedge$ & 0 & 1 \\\hline
                        0   & 0 & 0 \\
                        1   & 0 & 1
                      \end{tabular} &
                                      \begin{tabular}{c|cc}
                                        $\rightarrow$ & 0 & 1 \\\hline
                                        0   & 1 & 1 \\
                                        1   & 0 & 1
                                      \end{tabular}  & 
                                                       
                                                       \begin{tabular}{c|cc}
                                                         $\oplus$ & 0 & 1 \\\hline
                                                         0   & 0 & 1 \\
                                                         1   & 1 & 0
                                                       \end{tabular} 
                    &
                      
                      
                      \begin{tabular}{c|cc}
                        $\leftrightarrow$ & 0 & 1 \\\hline
                        0   & 1 & 0 \\
                        1   & 0 & 1
                      \end{tabular} \\ 
    \end{tabular}

    \vspace{1cm}



    \begin{definition}
      A Boolean formula is defined inductively:
      \begin{itemize}
      \item The constants 0 and 1 are formulas.
      \item Every variable is a formula.
      \item If $F$ is a formula, then $\neg  F$ is a formula.
      \item The concatenation with a symbol of two formulas is a formula too.
      \end{itemize}
    \end{definition}

    Examples of formulas are $x\vee y$ or $x_1\wedge x_2 \vee  ( x_4 \vee \neg  x_3 \wedge (x_5\rightarrow x_6) \vee 0 )$. \\


    \begin{definition} Given a set $A$ it has an associated homonym problem that consists on, given an arbitrary element $e$ check if $e\in A$.	
    \end{definition}


    \begin{definition}
      An assignment is a function $\alpha$ from the set of Boolean formulas to the set of Boolean formulas, on which some variables $\{x_1,...,x_n \}$ are replaced by predefined constants $\{a_1,...,a_n\}$ respectively.\\
    \end{definition}

      If none of the variables altered by an assignment $\alpha$ are present on the formula $F$ then $\alpha(F) = F$. We denote as $Var(\alpha)$ the set of those variables that receive a value from $\alpha$. Analogously, $Var(F)$ will denote the variables present on a formula $F$.


    
    One can then \emph{apply} an assignment $\alpha$ to a formula $F$, denoting it by $F\alpha=\alpha(F)$. To describe an assignment we will use a set that pairs each variable to it value, i.e. $\alpha=\{x_1\to 1,...,x_n\to 0\}$. For example given an assignment $\alpha_0 = \{x_1 \to 1, x_2\to 1, x_3 \to 0\}$ and $F_0=x_1\to (x_2\wedge x_4)$ then  $F_0\alpha_0=1 \to (1\wedge x_4)= x_4$. \\
    
    \begin{definition}
      An assignment is said to \emph{satisfy}  a formula $F$ if $F\alpha=1$ and in the case $F  \alpha = 0 $ it is said to \emph{falsify} the statement.
    \end{definition}
    
    \begin{definition}
      A formula $F$ is called \emph{satisfiable} if $\exists \alpha : F\alpha = 1.$ Otherwise it is called \emph{unsatisfiable}. The set of all satisfiable formulas is denoted as $SAT$.  The problem $SAT$ is the associated problem. 	An assignment $\alpha$ that satisfies $F$ is called a model an is denoted as $\alpha \models F$.\\
      
      
      A formula $F$ such that for every  $\alpha$ assignment happens that $F\alpha=1$ is a tautology. Given two formulas $G,F$ it is said that $G$ follows from $F$ if $F\rightarrow G$ is a tautology. \\
    \end{definition}
    
    
    
    \begin{definition}
      A formula $F$ is said to be in conjunctive normal form if is written as:
      $$F = C_1\wedge ... \wedge C_n$$
      Where $C_i = (u_{1,i} \vee ... \vee u_{m_i,i})$  and $u_{i,j}$ are literals, that is, variables or negated variables. The set of all formulas in conjunctive normal form is called \emph{CNF}.

      A literal $u$ is a pure literal if there is no $\neg u$ in $F$
    \end{definition}
    
    A formula in \emph{CNF} could be seen as a collection of clauses. The associated problem with \emph{CNF} is straightforward on $O(n)$. The problem that we will investigate is whether a arbitrary formula $F$ have a \emph{SAT-equivalent} \emph{CNF} formula.
    Equivalently a clause could be seen as a set of literals. The set of all formulas in conjunctive normal form where $|C_i| = N\ i \in 1,...,n$ is called \emph{NCNF}. The intersection of these set with the \emph{SAT} sets are called \emph{CNF-SAT} y \emph{NCNF-SAT}. If the context is clear enough the problems will be called \emph{CNF} and \emph{NCNF}\\


    We could define an equal relationship on the set of formulas. Let $F,G$ be formulas. Then $F= G$ if it happens that for each $\alpha$ an assignment such that $F\alpha = 1$ then $G\alpha = 1$ and $G\alpha = 1$ then $F\alpha = 1$

    \begin{proposition} 
      The given equal relationship is a equivalence relationship.
    \end{proposition}
    \begin{proof}
      All three properties follows from the equivalent properties on the constants.

    \end{proof}
    
    
    We could define a partial order relation between the formulas.	Let $F,G$ be formulas. Then $F\le G$ if it for each $\alpha$ an assignment such that $F\alpha = 1$ then $G\alpha = 1$. \\
    
    
    \begin{proposition} 
      The given order relationship is well-defined.
    \end{proposition}
    \begin{proof}
      As we then could see each class of equivalent as the set of assignment that satisfies all of the clauses, this property arises from the order given by the inclusion on sets.\\
    \end{proof}


    TODO: Definir un circuito.
    
    \begin{lemma}
      For every \emph{SAT} formula there is an associated circuit.
    \end{lemma}
    \begin{proof}
      Every operator can be seen as a gate and every variable as an input.\\
    \end{proof}
    
    \begin{theorem}[Tseitin \cite{tseitin1983complexity}]
      There is a \emph{3-CNF} formula on each equivalent class. Moreover, given an element $F$  there is a equivalent formula $G$  in \emph{3-CNF} which could be computad in polynomial time. 
    \end{theorem}

    \begin{proof}
      We will show that for every circuit with $n$ inputs and $m$ binary gates there is a formula in \emph{3-CNF}  that could be constructed in polynomial time in $n$ and $m$. Then, given a formula we will work with it considering its associated circuit.\\
<
      We will construct the formula considering variables $x_1,...,x_n$ that will represent the inputs and $y_1,...,y_m$ that will represents the output of each gate. 

      $$ G = (y_1) \wedge \bigwedge_{i=1}^m (y_i \leftrightarrow f_i(z_{i,1},z_{i,2}))$$

      Where $f_i$ represents the formula associated to the $i$-gate, $z_{i,1},z_{i,2}$ each of the two inputs of the $i$-gate, whether they are $x_-$ or $y_-$ variables. This formula is not \emph{3-CNF} yet, but for each configuration being $f_i$ a Boolean operator there would be a \emph{3-CNF} equivalent.

      \begin{itemize}
      \item $z \leftrightarrow( x \vee y )  = \neg  ( z \vee  x \vee y    ) \vee (z \wedge ( x \vee y )  ) = \neg  ( z \vee  x \vee y    ) \vee (z \wedge x)  \vee (z \wedge y ) =$\\$= ( \neg  z \wedge  \neg  x \wedge \neg   y    ) \vee (z \wedge x)  \vee (z \wedge y )  =$$
        (\neg  z \vee (z \wedge x)  \vee (z \wedge y ))  \wedge  
        (\neg  x \vee (z \wedge x)  \vee (z \wedge y )) \wedge
        (\neg  y \vee (z \wedge x)  \vee (z \wedge y ))   =
        (\neg  z \vee x  \vee y )  \wedge  
        (\neg  x \vee z  ) \wedge
        (\neg  y \vee z ) $   
      \item $z \leftrightarrow( x \wedge y ) = \neg ( z \vee ( x \wedge y )) \vee (z \wedge ( x \wedge y )) = (z\wedge x \wedge y ) \vee  (\neg  z\wedge \neg  x \wedge \neg  y )  =$\\$\ \ \ ((z\vee  (\neg  z\wedge \neg  x \wedge \neg  y )  ) \wedge (x \vee  (\neg  z\wedge \neg  x \wedge \neg  y )  ) \wedge (y\vee  (\neg  z\wedge \neg  x \wedge \neg  y )  ) ) = (\neg  x \vee z) \wedge (\neg  y \vee z ) \wedge (\neg  z \vee x ) \wedge (\neg  y \vee x ) \wedge(\neg  z\vee y )\wedge (\neg  x\vee y )$
	
      \item $z \leftrightarrow( x \leftrightarrow y ) =  \neg ( z \vee ( x \leftrightarrow y ) ) \vee (z \wedge ( x \leftrightarrow y ) = \neg ( z \vee (\neg  x \wedge \neg  y) \vee (x \wedge y)) \vee (z \wedge(\neg  x \wedge \neg  y) \vee (x \wedge y))  )=(\neg  z \wedge \neg  (\neg  x \wedge \neg  y) \wedge \neg  (x \wedge y)) \vee (z \wedge(\neg  x \wedge \neg  y) \vee (x \wedge y))  )=(\neg  z \wedge  (x \vee  y) \wedge (\neg  x \vee \neg  y)) \vee (z \wedge(\neg  x \wedge \neg  y) \vee (x \wedge y))  )=z \vee ( \neg  x \wedge \neg  y) = (\neg x \vee \neg y \vee z) \wedge (\neg x \vee \neg z \vee y) \wedge (y \vee z \vee x) \wedge (y \vee \neg y \vee x) \wedge (\neg z \vee z \vee x) \wedge (\neg z \vee \neg y \vee x)$
	
      \item $z \leftrightarrow( x \oplus y ) =  z \leftrightarrow(\neg  x \leftrightarrow y )  $	

      \end{itemize}
      In the last item we use the third one.
      
    \end{proof}
    This result is important because, now we could be able to talk only about \emph{3-CNF} formulas. The fact that they are reachable on polynomial time is important because it means it could be done efficiently. Should this be impossible it will not be of much relevance in practice, as we yearn to solve this problem as efficient as possible (in fact, as polynomial as possible). This result implies that if we know how to solve \emph{3-CNF} then we will be able to solve 'full'SAT problems.
    \begin{definition}
      An assignment \alpha is called autark for a formula $F\in$\emph{CNF} if for every clause $C \in F$ it happens that if $Var(C) \cap Var(\alpha) \ne \emptyset $ then $C\alpha = 1$, in other words it satisfies all clauses that it 'touches'. 
    \end{definition}

    The use of this definition is self-evident, as it would simplify the problem of resolving a \emph{CNF} clause. The strategy would be simple as obvious: try to make every clause positive. This assignment will give simplifications of the problem, and enabling a good method for the search will be useful.\\ 

    Should it happen that we got an algorithm for autarks clauses, and iterating it, we could find a solution of any given formula. Finding a polynomial algorithm that finds whether there exists any non-empty autark formula and provide it, we could be able of proving that NP = P, as we could solve SAT applying this algorithm iteratively. Anyway, trying to find simple autark assignment, i.e. assignment with not many variables,is a good praxis.

    \begin{proposition} We could reduce the SAT-CNF problem to the Autark-Finding problem.
      \begin{proof} Suppose that an algorithm such that if it exists any autark it return one of them, and end with an error code otherwise is given.  \\

        Given a formula $F$, if there is not an autark then there is no solution for the SAT problem. If it finds an Autark-assignment $\alpha$ then we apply the same algorithm to $\alpha(F)$. Also, as it happens that $|Var(\alpha(F))|<|Var(F)|$ so we would only apply the algorithm finitely many times. Also, $F$ will be solvable if, and only if, $F\alpha$ is solvable.	\\

        Moreover, as checking whether an assignment is autark is linear on the number of clauses, then this make the autark-finding problem NP-Complete(NP-C further on).
      \end{proof}
      
    \end{proposition}



    \begin{proposition}
      Given a tautology $F \to G$, there exists a formula $I$ such that $Var(I) = Var(F)\cap Var(G)$ and both $F\to I$ and $I \to G$ are tautologies. A polynomial algorithm to solve this problem is not known. 
    \end{proposition}

    \begin{proof} Let $\{x_1,...,x_k\} = Var(F)\cup Var(G)$ then we will build $I$ by defining its truth table in the following way: Given an assignment $\alpha$:
      \[   
        I\alpha = 
        \begin{cases}
          1&\quad\text{if $\alpha$ could be extended to an assignment that \emph{satisfies} $F$}, \\
          0&\quad\text{if $\alpha$ could be extended to an assignment that \emph{nullifies} $G$},\\
          * &\quad\text{otherwise.} \\ 
        \end{cases}
      \]

      Where * mean that it could be either 0 or 1.  This is well defined because if for an arbitrary $\alpha$ it happens that $G\alpha = 0$ then $F\alpha = 0$.

      For every assignment $\beta$ such that $Var(\beta) = Var(F)\cup Var(G)$ then if $\beta(F) = 1$ then $\beta(I) = 1$ so $F \to I$  is a tautology. Similarly it can not happen that $I\beta = 1 $ and $G\beta = 0$, because the second will imply that   $I\beta = 0$.\\

      For the last part we will refer to the paper on the topic by: \red{TODO}



    \end{proof}

