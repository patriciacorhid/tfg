% Chapter 1
\part{Reductions} % Main chapter title

\label{chap:3}


\chapter{Development}
\section{Development Environment}

In this chapter we briefly introduce the development environment used to program reductions.\\

We use the programming language \texttt{Python} for three main reasons:

\begin{itemize}
\item \texttt{Python} is interpreted. Furthermore, it is compatible with major platforms and systems. This allow us to develop a program that is accessible to virtually everyone without the need of compiling the program multi-platform. 

\item \texttt{Python} is considered to have one of the most accessible learning curves. Therefore, is excellent to introduce to reductions programming to those who are mostly interested in the theoretical part.

\item \texttt{Python}  and all necessary software dependencies is  free software\cite{stallman2002free}. I believe that, whenever possible, public-funded research should be accessible to everyone interested. This implies reducing the barriers to access to knowledge to a minimum.  Furthermore, it must not encourage the economic gain of a third party private entity that is not even aware of the existence of the project by making it compulsory to use it for the full exploitation of the project carried out.
\end{itemize}



All test cases are done in an ARCH-BASED OS. In particular:

  {\begin{center}
      \texttt{Linux 4.19.122-1-MANJARO  2020 x86\_64\ GNU/Linux}\\
    \end{center} }

  With 4 physical (8 virtual) processor \texttt{Intel(R) Core(TM) i7-8550U CPU @ 1.80GHz}. 

  
\section{PySAT}
PySAT\cite{imms-sat18} is a library developed for python SAT solving. It has been primarily develop by Alexey Ignatiev, Antonio Morgado, Joao Marques-Silva since 2018. Among their feature we can highlight:

\begin{itemize}
\item Solvers:  PySAT include some solvers of great diffusion. Namely
  \begin{itemize}
  \item CaDiCaL: A CDCL based, developed by Armin Biere et al. Armin Biere is one of the leading voices in SAT Solving. Is one of editors of Handbook of Satisfiability. CaDiCaL won the SAT Race 2019.
  \item MapleSAT: Another variations of DPLL. It used an specific heuristic: the learning rate branching heuristic (LRB), which is inspired in the ones that are used for in Machine Learning as in Decision Trees. MapleSAT is develop by the University of Waterloo, and is the winner of SAT competition 2018.
  \item Minisat: is ''a minimalistic, open-source SAT solver, developed to help researchers and developers alike to get started on SAT.'' Is one of the main references in SAT solving. This year SAT competitions included a MiniSAT Hack Track, that aim to display the best improvements possible to the classical MiniSAT with only minor changes (<10 lines).
  \end{itemize}

  We will use generally the solver CaDiCaL. The solvers read a formula as a list of list of integers, negated or not. Should an integer $n$ exists, it assumes that all integer in $\{1,...,n\}$ exists as variable. Each particular solver is a class. The class \texttt{Solver} is a wrapper that works as an interface between the users and a solver. 


  
\item Cardinality Encodings: PySAT includes a series of cardinality encodings. This will take an important in the development. This will take an important in the development, as this type of constraints are commonplace on problems. An example the formula explained in the lemma[\ref{lemma:cooklevin}], that is the called pairwise encoding. There are two classes involved:
  \begin{itemize}
  \item \texttt{IDPool}: a class that help us manage variables without having personally to have a log of what variable is associated to each integer. Nonetheless, we do not consider this class to be a black box. Reading the code we recognize that the variables are named after their order of arrival. This details is important in order to solve some function problems.
  \item \texttt{CardEnc}: a class that allow us to encode cardinality restrictions of the type atmost, atleast and equals. I feel proud to say that I notified a bug in this particular class relative to a unidiomatic use of python that derived in a error, while thoroughly studying the project.  
  \end{itemize}

\end{itemize}


\section{Path based Problems}


In order to demonstrate the utility of SAT a series of reductions will be developed. This will imply a formal approach to the resolution of the problems, as well as deploying a little theoretical background to some problems when needed. Also we would like to show that this technique provide sometimes really simple approximations to the problems. We start approaching graph related problems, for two reasons:

\begin{enumerate}
\item The graphs arouse interest both in mathematics and in computer science, thus deriving a work that could be interesting for profiles coming from both subjects.
\item We want to use SAT to solve problems at least as complex as SAT. Thus, we look for problems that are NP-Hard. Some of the most important classical NP-Problems\ are defined over graphs. 
\end{enumerate}



\subsection{Resolutions}

\subsubsection{Hamiltonian Path}

The problem of, given a graph, whether it exists a Hamiltonian Path is well know to be NP-Complete. Then by Cook Theorem it is known that a reduction from the problem of the Hamiltonian Cycle to SAT exists. This theorem is constructive, so it effectively does gives a reduction. Nonetheless, this reduction is unmanageable and in order to use SAT-solvers to improve Hamiltonian cycle resolution it would be necessary to provide easier programming techniques. On this subsection an alternative reduction will be shown.

\begin{definition}
  A Hamiltonian cycle is a cycle that visits every node in a graph. The associated problem is to check, given a graph, whether whether cycle exists.
\end{definition}

We will consider the problem of the Hamiltonian cycle of undirected graphs. Therefore an edge would have two sources instead of a source and a target as it is regarded on directed graphs.\\

This problem is a very good example to represent what means to use a SAT-solver to solve a hard problem. The presented reduction is done as shown in \cite{49593}, with a minor error solved.\\


It moves the complexity of the problem from how to solve it to how to implement a SAT-solver. Therefore it only left a worry about what do I need to satisfy in order to solve this problem. In order to make the reduction we will represent with Boolean clauses the conditions. We use the same reduction in order to reduce both the problem for the Hamiltonian path and the Hamiltonian cycle.\\

Let $G=(V=\{ v_1,...,v_n\},E= \{e_1,...,e_m\})$ be a graph. To reduce it to a SAT problem, we will first define the variables $\{x_{i,j}: i\in 1,...,n ; j\in 1,...,n \}$. If the variable $x_{i,j}$ is assigned to true it would mean that the vertex $v_i$ is in position $j$ in the path. We would like to find a assignment of these variables that satisfy the following clauses. When we note $\mathcal{C}(A)$ we refer in the context of the lemma \ref{lemma:cooklevin}.


\begin{enumerate}
\item Each vertex must appear at least once in the path, and only one. Thus, for every vertex $v_i$:
  $$\mathcal{C}( \{x_{i,j} : j \in 1,...,n \}) \qquad i \in 1,...,n.$$

\item Every position in the path must has an associated vertex, and only one:
  $$\mathcal{C}( \{x_{i,j} : i \in 1,...,n \}) \qquad j \in 1,...,n.$$
\item Two consecutive vertices have to be adjacent:
  $$(\neg x_{i,j} \vee \neg x_{i+1,k})\qquad \forall (k,j) \not \in E, i \in 1,...,n-1.$$
\item Should a cycle be wanted, we add:
  $$(\neg x_{1,j} \vee \neg x_{n,k})\qquad \forall (k,j) \not \in E.$$
\end{enumerate}

Let now prove that this is a correct reduction, i.e., that an assignment that can satisfy these clauses exists if, and only if, the graph $G$ has a Hamiltonian graph. If such an assignment exists we can make a Hamiltonian cycle with the variables assigned to 1. On the other hand if such cycle exists an assignment that assign to 1 the variable $x_{i,j}$ given that the vertex $v_i$ is in position $j$ in the path would satisfy all the clauses. 

\subsubsection{Coloring}



\subsection{Implementation}

In this subsection, once we have proved the reduction in a constructive way, we proceed to program this in order to make this ideas usable.

\subsubsection{Planning and Budgeting}

We consider that we have to face three problems:
\begin{itemize}
\item Representation of the graph. We want to make an elegant yet useful representation of the graph. After checking some implementations we decide to improve one simply enough to do our job. We choose the basic implementation from \cite{graphAdvanced}. We like the fact that it used a dictionary, that that naturally represents a graph. We improve two major details:
  \begin{enumerate}
  \item The class is decided to has a graph as a god-object on which resides all the work. As recommended in \cite{slatkin2019effective}, we choose to inherit directly from dict, in order to gain some strength in processing.
  \item We consider a set to be better to represent the adjacent nodes, as the order that a list provide is useless and difficult membership checking.
  \end{enumerate}

\item Develop of the reduction.
\item Adapt the reduction to the solver.

\end{itemize}


We plan one week to fully implement this work. 

\subsubsection{Analysis and Design}






\subsubsection{Test}

In order to automatize testing we use the \texttt{Python} class of test classes. Therefore we can use automatic test cases in order to check our implementations. The work-flow followed is an agile one, on which we first define the objective of each code along with the test cases that we want it to pass, and then we start to develop the code. 
We use the class \texttt{graph\_test.py} to test the Graph class. \\

In order to check the implementation an scalability of our program we search for some bigger graph that we can define by hand. We find the NPDatalog graph database \cite{NPDatalog}.