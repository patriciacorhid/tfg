% Chapter 1
\part{Reductions} % Main chapter title

\label{chap:3}


\chapter{Development}

The objective of this chapter is to develop a brief work based mostly on original ideas as a final step to an extensive work of deepening in an area of knowledge. It also seeks to illustrate some of the skills acquired during the degree in the context of programming, as well as to develop tools that are of practical interest in the field of mathematics. \\

To this end, we are going to create a library in the Python programming language that will allow us to solve np-complete problems in an elegant and efficient way.  We will consider graph, hypergraph, and other problems. 

\section{Development Environment}

In this chapter we briefly introduce the development environment used to program reductions.\\

We use the programming language \texttt{Python} for three main reasons:

\begin{itemize}
\item \texttt{Python} is interpreted. Furthermore, it is compatible with major platforms and systems. This allow us to develop a program that is accessible to virtually everyone without the need of compiling the program multi-platform. 

\item \texttt{Python} is considered to have one of the most accessible learning curves. Therefore, is excellent to introduce to reductions programming to those who are mostly interested in the theoretical part.

\item \texttt{Python}  and all necessary software dependencies is  free software\cite{stallman2002free}. I believe that, whenever possible, public-funded research should be accessible to everyone interested. This implies reducing the barriers to access to knowledge to a minimum.  Furthermore, it must not encourage the economic gain of a third party private entity that is not even aware of the existence of the project by making it compulsory to use it for the full exploitation of the project carried out.
\end{itemize}



All test cases are done in an ARCH-BASED OS. In particular:

  {\begin{center}
      \texttt{Linux 4.19.122-1-MANJARO  2020 x86\_64\ GNU/Linux}\\
    \end{center} }

  With 4 physical (8 virtual) processor \texttt{Intel(R) Core(TM) i7-8550U CPU @ 1.80GHz}. 

  
\section{PySAT}
PySAT\cite{imms-sat18} is a library developed for python SAT solving. It has been primarily develop by Alexey Ignatiev, Antonio Morgado, Joao Marques-Silva since 2018. Among their feature we can highlight:

\begin{itemize}
\item Solvers:  PySAT include some solvers of great diffusion. Namely
  \begin{itemize}
  \item CaDiCaL: A CDCL based, developed by Armin Biere et al. Armin Biere is one of the leading voices in SAT Solving. Is one of editors of Handbook of Satisfiability. CaDiCaL won the SAT Race 2019.
  \item MapleSAT: Another variations of DPLL. It used an specific heuristic: the learning rate branching heuristic (LRB), which is inspired in the ones that are used for in Machine Learning as in Decision Trees. MapleSAT is develop by the University of Waterloo, and is the winner of SAT competition 2018.
  \item Minisat: is ''a minimalistic, open-source SAT solver, developed to help researchers and developers alike to get started on SAT.'' Is one of the main references in SAT solving. This year SAT competitions included a MiniSAT Hack Track, that aim to display the best improvements possible to the classical MiniSAT with only minor changes (<10 lines).
  \end{itemize}

  We will use generally the solver CaDiCaL. The solvers read a formula as a list of list of integers, negated or not. Should an integer $n$ exists, it assumes that all integer in $\{1,...,n\}$ exists as variable. Each particular solver is a class. The class \texttt{Solver} is a wrapper that works as an interface between the users and a solver. 


  
\item Cardinality Encodings: PySAT includes a series of cardinality encodings. This will take an important in the development. This will take an important in the development, as this type of constraints are commonplace on problems. An example the formula explained in the lemma[\ref{lemma:cooklevin}], that is the called pairwise encoding. There are two classes involved:
  \begin{itemize}
  \item \texttt{IDPool}: a class that help us manage variables without having personally to have a log of what variable is associated to each integer. Nonetheless, we do not consider this class to be a black box. Reading the code we recognize that the variables are named after their order of arrival. This details is important in order to solve some function problems.
  \item \texttt{CardEnc}: a class that allow us to encode cardinality restrictions of the type atmost, atleast and equals. I feel proud to say that I notified a bug in this particular class relative to a unidiomatic use of python that derived in a error, while thoroughly studying the project.  
  \end{itemize}

\end{itemize}


\section{Reductions}
\subsection{Graph based Problems}
In order to demonstrate the utility of SAT a series of reductions will be developed. This will imply a formal approach to the resolution of the problems, as well as deploying a little theoretical background to some problems when needed. Also we would like to show that this technique provide sometimes really simple approximations to the problems. We start approaching graph related problems, for two reasons:

\begin{enumerate}
\item The graphs arouse interest both in mathematics and in computer science, thus deriving a work that could be interesting for profiles coming from both subjects.
\item We want to use SAT to solve problems at least as complex as SAT. Thus, we look for problems that are NP-Hard. Some of the most important classical NP-Problems\ are defined over graphs. 
\end{enumerate}



 
We choose to solve four of the 21 Karp's NP-Complete problems\cite{karp1972reducibility}, namely:
\begin{itemize}
\item Hamiltonian Path.
\item Proper Coloring.
\item Vertex Covering.
\end{itemize}

When we talk about graph in this subsection we will consider undirected graphs only, that is, undirected graphs without more than one edge between two nodes and no loops.

These problems are among the most representatives of graphs theory, so we believe of great interest developing a library to solve then. Thorough the chapter, when we refer to $\mathcal{C}(A)$ we refer in the context of the lemma \ref{lemma:cooklevin}.


\subsubsection{Hamiltonian Path}

The problem of, given a graph, whether it exists a Hamiltonian Path is well know to be NP-Complete. Then by Cook Theorem it is known that a reduction from the problem of the Hamiltonian Cycle to SAT exists. This theorem is constructive, so it effectively does gives a reduction. Nonetheless, this reduction is unmanageable and in order to use SAT-solvers to improve Hamiltonian cycle resolution it would be necessary to provide easier programming techniques. On this subsection an alternative reduction will be shown.

\begin{definition}
  A Hamiltonian cycle (resp. path) is a cycle (resp. path) that visits every node in a graph. The associated problem is to check, given a graph, whether such cycle (resp. path) exists.
\end{definition}

We will consider the problem of the Hamiltonian cycle of undirected graphs. Therefore an edge would have two sources instead of a source and a target as it is regarded on directed graphs.\\

This problem is a very good example to represent what means to use a SAT-solver to solve a hard problem. The presented reduction is done as shown in \cite{49593}, with a minor error solved.\\


It moves the complexity of the problem from how to solve it to how to implement a SAT-solver. Therefore it only left a worry about what do I need to satisfy in order to solve this problem. In order to make the reduction we will represent with Boolean clauses the conditions. We use the same reduction in order to reduce both the problem for the Hamiltonian path and the Hamiltonian cycle.\\

Let $G=(V=\{ v_1,...,v_n\},E= \{e_1,...,e_m\})$ be a graph. To reduce it to a SAT problem, we will first define the variables $\{x_{i,j}: i\in 1,...,n ; j\in 1,...,n \}$. If the variable $x_{i,j}$ is assigned to true it would mean that the vertex $v_i$ is in position $j$ in the path. We would like to find a assignment of these variables that satisfy the following clauses.


\begin{enumerate}
\item Each vertex must appear at least once in the path, and only one. Thus:
  $$\mathcal{C}( \{x_{i,j} : j \in 1,...,n \}) \qquad i \in 1,...,n.$$

\item Every position in the path must has an associated vertex, and only one:
  $$\mathcal{C}( \{x_{i,j} : i \in 1,...,n \}) \qquad j \in 1,...,n.$$
\item Two consecutive vertices have to be adjacent:
  $$(\neg x_{i,j} \vee \neg x_{i+1,k})\qquad \forall (k,j) \not \in E, i \in 1,...,n-1.$$
\item Should a cycle be wanted, we add:
  $$(\neg x_{1,j} \vee \neg x_{n,k})\qquad \forall (k,j) \not \in E.$$
\end{enumerate}

Let now prove that this is a correct reduction, i.e., that an assignment that can satisfy these clauses exists if, and only if, the graph $G$ has a Hamiltonian graph. If such an assignment exists we can make a Hamiltonian cycle with the variables assigned to 1. On the other hand if such cycle exists an assignment that assign to 1 the variable $x_{i,j}$ given that the vertex $v_i$ is in position $j$ in the path would satisfy all the clauses. 

\subsubsection{The optimization trick}

The next problems that we consider have a characteristic in common: they are optimizing problem with an associated NP-Complete decision problem. That is, we have a decision problem that, given a graph $G$ and a number $k$, check whether a condition is satisfied, and an associated minimizing (resp. maximizing) problem that consists of looking for the least (resp. greatest) $k$ where the conditions are satisfy for $G$. For the rest of the discussion we consider that we can solve the decision problem in $O(f(n))$ for some $f\in \mathbb{N}^\mathbb{N}$. \\

The naive approach is straight forward: trying iteratively try every $k$ increasingly (resp. decreasingly) until some satisfy the condition, therefore finding the minimum (resp. maximum). As in all three problems it happens that $1\le k \le n$ therefore we can solve the function problem in $O(nf(n))$. \\

Nonetheless there is a somewhat common trick that consist of using one more property of these type of problem: if the conditions are satisfied for a number $k$ then they are satisfy for every $k' \ge k$. Therefore we can implement a binary search, therefore achieving a better efficiency $O(log(n)f(n))$.\\


\begin{algorithm}
  \caption{Optimization trick for minimizing}\label{bt}
  \begin{algorithmic}[1]
    \State $G \gets$ a graph.
    \Procedure{\texttt{Minimizing}}{$G$}
    \State old $\gets$ maximun value for $k$
    \State new $\gets$ old / 2
    \While{ old $\neq$ new}
        \If{ \texttt{decision\_problem}($G$,new)}
         \State   old $\gets$ new
         \State   new $\gets$ new / 2
         \Else
         \State new $\gets$ (old - new) / 2
         \EndIf
    \EndWhile
    \State \Return new
  \end{algorithmic}
\end{algorithm}

This method allow us to study the decision problem, and having an slightly refined algorithm to solve the associated optimization problem. 

\subsubsection{Coloring}

We now introduce one of the most active problems in graph theory: the graph coloring. In this text we have already consider graph coloring, defined in definition \ref{def:coloring}. In that context we focus on  trying to find a stable coloring in order to exploit symmetry in formulas, we now focus on \emph{proper colorings}.



\begin{definition}
  Let $G=(V,E)$ be a graph and let $\pi$ be a coloring of $G$. We say that $\pi$ is a \emph{proper coloring} of $G$ if not two adjacent vertices belong to the same color.  
\end{definition}

\begin{definition}
  The Graph Proper Coloring Language is the language $L\subset \text{GRAPH}\times \mathbb{N}$, such that for every $(G,k)\in L$ there exists a proper coloring $\pi$ of $G$ such that $|\pi| = k$.  
\end{definition}

The  Graph Proper Coloring Decision problem is a well-known NP-Complete problem. We will reduce this problem to SAT in order to make use of efficient solvers, nonetheless, we will first consider a bit generalization of the problem.

\begin{definition}
  We define the chromatic number function $\chi:\text{GRAPH}\to \mathbb{N}$ as follows:
  $$ \chi(G) = \min\{|\pi|: \pi \text{ is a proper coloring of } G\} \qquad \forevery G \in \text{GRAPH}$$. 
\end{definition}

We get an associated function problem by considering the relation $R \subset \text{GRAPH}\times \mathbb{N}$ such that $R = \{(G,\chi(G)): \forevery G \in \text{GRAPH}.\}$. This problem is NP-Hard, as a simple result of the following remark.

\begin{remark}
  Let $L$ be  The Graph Proper Coloring Language. If $(G,k) \in L$ we have that $(G,k')\in L$ for every $k'\ge k$.
\end{remark}

Therefore being able to solve this problem is enough to be able to solve the coloring problem. This remark also allow us to use the Optimization trick for minimizing, if we find a upper bound for $k$. This upper bound  is the number of vertices, as every discrete coloring is a proper coloring. Let's therefore solve the decision problem and we will solve both problem described in this subsubsection as a consequence.\\

Let $G=(V=\{ v_1,...,v_n\},E= \{e_1,...,e_m\})$ be a graph and let $k\in \mathbb{N}$. To reduce it to a SAT problem, we will first define the variables $\{x_{i,j} : 1\le i \le n,  1 \le j \le k\}$. If the variable $x_{i,j}$ is assigned to true, it would means that the vertex $v_i$ is in the color $k$. We would like to find a assignment of these variables that satisfy the following clauses.
\begin{enumerate}
\item Each vertex should have one and only one coloring. Thus, for every vertex $v_i$:
  $$\mathcal{C}( \{x_{i,j} : j \in 1,...,k \}) \qquad \forall i \in 1,...,n.$$
\item No two adjacent vertices should have the same color:
$$(\neg x_{i,j}, \neg x_{k,j}) \qquad \forall (i,k) \in E,\ \forall j \in 1,...,k.$$
\end{enumerate}

Let now prove that this is a correct reduction. If there exists a satisfying assignment of the following clauses, thanks to 1. we can define a coloring of $G$ and thanks to 2. such coloring is a proper coloring. Reversely should that coloring exists we can define a satisfying assignment $\alpha$ as:
$$\alpha(x_{i,j}) = 1_{V_j} (v_i),$$

where $1_{V_j}$ is the characteristic function of $V_j$.


\subsubsection{Vertex cover}

As in the previous subsubsection this problem is among the ones that consist on a NP-Complete decision problem with an associated NP-Hard minimizing problem. Vertex covering are used in planification in order to ensure supply of areas using the minimum amount of resources. 

\begin{definition}
  Let $G=(V,E)$ be a graph and let $V' \subset V$. We say that $V$ is a \emph{vertex cover} of $G$ for every $v\in V$ there exists some $v'\in V' $ such that $(v,v')\in E$.
\end{definition}


\begin{definition}
  The Graph Vertex Cover Language is the language $L \subset \text{GRAPH} \times \mathbb{N}$, such that for every $( G, k ) \in L$ there exists a vertex cover $V'$  of $G$ such that $ |V'|= k$
\end{definition}





\subsection{Implementation}

In this subsection, once we have proved the reduction in a constructive way, we proceed to program this in order to make these ideas usable.

\subsubsection{Planning and Budgeting}

We consider that we have to face three problems:
\begin{itemize}
\item Representation of the graph. We want to make an elegant yet useful representation of the graph. After checking some implementations we decide to improve one simply enough to do our job. We choose the basic implementation from \cite{graphAdvanced}. We like the fact that it used a dictionary, that that naturally represents a graph. We improve two major details:
  \begin{enumerate}
  \item The class is decided to has a graph as a god-object on which resides all the work. As recommended in \cite{slatkin2019effective}, we choose to inherit directly from dict, in order to gain some strength in processing.
  \item We consider a set to be better to represent the adjacent nodes, as the order that a list provide is useless and difficult membership checking.
  \end{enumerate}

\item Develop of the reduction.
\item Adapt the reduction to the solver.

\end{itemize}


We plan one week to fully implement this work. 

\subsubsection{Analysis and Design}






\subsubsection{Test}

In order to automatize testing we use the \texttt{Python} class of test classes. Therefore we can use automatic test cases in order to check our implementations. The work-flow followed is an agile one, on which we first define the objective of each code along with the test cases that we want it to pass, and then we start to develop the code. 
We use the class \texttt{graph\_test.py} to test the Graph class. \\

In order to check the implementation an scalability of our program we search for some bigger graph that we can define by hand. We find the NPDatalog graph database \cite{NPDatalog}.