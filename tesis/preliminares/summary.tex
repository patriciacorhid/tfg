%*******************************************************
% Summary
%*******************************************************

\newpage



\chapter*{Summary}
\addcontentsline{toc}{chapter}{Summary}
\section*{Brief Summary}



\section*{Resumen Extendido}

Durante la redacción de este trabajo estudiaremos un campo multidisciplinar que involucra, por lo general, tanto consideraciones propias de los intereses de las matemáticas como de los intereses del campo de la ingeniería informática. Por lo tanto, es difícil distinguir a grandes rasgos que partes son de mayor interés para un lector que pertenezca a solo una de las disciplinas. Sin embargo, intentaremos diferenciar en la medida de lo posible, que partes son de interés para cada una de dichas disciplinas. En caso de que esto no sea posible, justificaremos el interés que cada ciencia tiene.\\

La primera parte introduce el problema y estudia su complejidad. Procedemos a explicar que realizamos en cada capítulo.\\

\textbf{Capítulo 1:} En este capítulo exponemos los fundamentos de la lógica. El objetivo es introducir con la máxima formalidad posible el marco de trabajo durante todo el proyecto. 
Empezamos definiendo el Álgebra Booleana como un retículo distributivo. Posteriormente, demostramos el teorema de Knaster-Tarski para retículos completos. Definimos a continuación la Lógica Proposicional como un Lenguaje Formal. De este modo, primero especificamos la sintaxis y la semántica de este idioma. Definimos una semántica basada en asignaciones y asignaciones parciales. Consideramos que este capítulo suscita un interés principal en el campo de la matemática. Sin embargo, es recomendado que todo lector lo lea para poder comprender en toda su extensión los capítulos subsecuentes.\\

\textbf{Capítulo 2:} En este capítulo, definimos formalmente lo que es un problema e introducimos el problema SAT como un problema de decisión sobre el lenguaje de la lógica proposicional. Un  problema de decisión puede entenderse como un problema cuya respuesta es sí o no. La decisión que toma el problema SAT es decidir si una fórmula es satisfacible, esto es, si bajo alguna configuración de verdad esta es cierta. Análogamente, definimos las variaciones de este problema que suscitan más interés, y que estudiaremos en el siguiente capítulo. Continuamos demostrando como se realiza un certificado de ejecución de SAT. Para ello demostramos la completitud de la regla de resolución. Por último, hablamos sobre los problemas de satisfacción de restricciones. Consideramos que la definición del problema es de interés para ambas disciplinas. La parte de completitud es más interesante para un punto de vista matemático, así como la última sección es más interesante para la ingeniería informática.\\

\textbf{Capítulo 3:}En la introducción hemos hablado del concepto de que todos los problemas de NP son como mucho tan difíciles como SAT. En ese capítulo presentaremos formalmente este resultado y lo demostraremos. En la última sección estudiaremos algunas nociones aledañas a SAT en relación a la teoría de la complejidad.\\

Para poder introducir el problema introducimos los modelos de computación, que nos servirán como base para, una vez definidos los problemas, resolverlos. Estos modelos se basan en la noción de máquina de Turing. Sobre estos modelos creamos una división de los problemas basada en su dificultad, que son las clases de complejidad, y presentamos algunas de las más importante como P,NP o LSPACE. Llegados a este punto introducimos el problema P vs NP, junto con otros resultados y problemas abiertos de interés.\\


La tercera sección está destinada a introducir la teoría necesaria para enunciar y demostrar el teorema de Cook-Levin. Una vez realizado este teorema lo aprovechamos e  introducimos una serie de resultados análogos en las diferentes variaciones de SAT, presentadas en el capítulo previo. Este teorema nos habla de la dificultad de SAT relativa a otros problemas de NP. Reflexionamos sobre la posibilidad de que SAT pertenezca a P presentado la hipótesis ETH, una hipótesis tan ampliamente aceptada como no demostrada.En la última sección realizamos un desarrollo de teorías asociadas con el problema SAT. En particular, estudiamos la acción de grupos de permutaciones y negaciones sobre fórmulas CNF. Presentamos las asignaciones Autark así como su NP-Completitud, desarrollamos el teorema de Tseitin que nos permita relacionar eficientemente SAT con GSAT, consideramos CO-NP completitud y, para terminar, consideramos FSAT y la relación entre los métodos constructivos y no constructivos de resolución.\\

En relación a la división del trabajo en informática y matemáticas, consideramos que este capítulo debe ser de interés para ambas disciplinas. Proseguimos explicando la siguiente parte. En esta, nos centramos en los algoritmos de resolución. Dividimos nuestro estudio de los algoritmos en tres capítulos.\\


\textbf{Capítulo 4:} En este capítulo estudiamos los algoritmos de resolución sobre conjuntos restringidos de SAT donde se pueden conseguir mejores resoluciones. Empezamos considerando restricciones aplicando nociones de combinatoria. Esta sección es naturalmente para el lector informático. Entre los métodos destacamos para el lector matemático la aplicación que explicamos del Lema Local de Lovasz, asociando un grafo de adyacencia a cada fórmula para poder aplicar el resultado. Proseguimos explicando los famosos casos de 2SAT y HORNSAT. \\

\textbf{Capítulo 5:} En este capítulo estudiamos los algoritmos completos de resolución de SAT. Las dos estrategias principales estudiadas son el algoritmo DPLL. Este es un algoritmo que, sin tener una complejidad teórica mejor que los métodos más obvios, introduce un uso de heurísticas y los algoritmos basados en mejoras de este tiene un lugar muy relevante entre los casos prácticos de resolución de SAT. Entre sus mejoras mejoras incluimos el algoritmo de Monien-Speckenmeyer y la explicación de los muy extendidos algoritmos de Conflict-Drive-Clause-Learning.\\

Tomando otro enfoque explicamos el método de búsqueda local ajustado a SAT. Una vez descrito lo mejoramos aplicando la teoría de código de cubrimientos. Esta sección consideramos que tiene un interés natural para el ámbito de la ingeniería informática. Desde el ámbito de las matemáticas el interés reside en el análisis de la complejidad de los algoritmos.\\

\textbf{Capítulo 6:} En este capítulo realizamos un estudio profundo del probablemente campo más activo de los algoritmos SAT-solver: el campo de los algoritmos probabilísticos. En estos algoritmos hacemos un compromiso en el cual a cambio de ganar en eficiencia admitimos algoritmos con un error unilateral acotado, es decir, un algoritmo que siempre responda correctamente si una formula no es satisfacible, y tenga una probabilidad de responder correctamente si lo es. Entre los algoritmos probabilisticos. Al igual que en la sección anterior estudiamos los dos enfoques: algoritmos basado en DPLL y algoritmos basados en busqueda Local. Entre los primeros estudiamos en profundidad el algoritmo PPZ y su mejora el algoritmos PPSZ. Este algoritmo es a día de hoy el que mejor eficiencia teórica presenta. En el ámbito de la búsqueda local encontramos el algoritmos de Schöning, que siendo uno de los más simples tiene una eficiencia no mucho pero a PPSZ. \\

Este capítulo es de interés para el ámbito de la informática debido al desarrollo de algoritmos de resolución. A su vez, un matemático puede ver reflejado sus intereses en la demostraciones realizadas para el estudio de la esperanza de error unilateral. Con esto acabamos la segunda parte.\\


\textbf{Capítulo 7:} Este capítulo, único perteneciente a la parte 3, narra el desarrollo de una librería en Python basada en PySAT. El objetivo de esta librería es realizar una resolución eficaz a la vez que elegante de problemas NP-Completos. Para esto realizamos reducciones de estos problemas al problema SAT. Esta librería resuelve los problemas NP-Completos de Coloreado, Cubrimiento por grafos y existencia de camino hamiltoniano en grafos, así como el problema de distancia en cadenas. Por último desarrollamos naiveQBF que tiene como esperanza ser un esqueleto eficiente para el desarrollo de QBFsolvers basados en SAT. El código asociado a esta librería esta disponible en:

\begin{center}
  \url{https://github.com/pedrobn23/TFG/}
\end{center}

El interés de esta sección para las matemáticas está en el desarrollo de herramientas para resolver problemas de su area de conocimiento. Para la informática está en las competencias demostradas en la organización, producción y acabado del código.\\

\textbf{palabras clave:} SAT, QBF, NP, NP-Completo, Cook-Levin, DPLL.





% \endinput
